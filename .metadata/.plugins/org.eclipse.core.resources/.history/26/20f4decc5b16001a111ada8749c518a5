import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;

import com.ibm.wala.ipa.callgraph.AnalysisCacheImpl;
import com.ibm.wala.ipa.callgraph.AnalysisOptions;
import com.ibm.wala.ipa.callgraph.AnalysisOptions.ReflectionOptions;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.CallGraphBuilder;
import com.ibm.wala.ipa.callgraph.Entrypoint;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.PointerAnalysis;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.ipa.modref.ModRef;
import com.ibm.wala.ipa.slicer.SDG;
import com.ibm.wala.ipa.slicer.Slicer.ControlDependenceOptions;
import com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions;
import com.ibm.wala.ipa.slicer.Statement;
import com.ibm.wala.shrikeCT.InvalidClassFileException;
import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.config.AnalysisScopeReader;
import com.ibm.wala.util.debug.Assertions;
import com.ibm.wala.util.io.FileProvider;
import com.ibm.wala.util.strings.Atom;

public class SDGCreateTest {
	private static ModRef<InstanceKey> modRef = ModRef.make();
	public static void main(String args[]) throws IOException, ClassHierarchyException, IllegalArgumentException, InvalidClassFileException, CancelException {

	    // 获得一个文件

	    File exFile=new FileProvider().getFile("Java60RegressionExclusions.txt");

	    // 将分析域存到文件中

	    AnalysisScope scope =
	        AnalysisScopeReader.makeJavaBinaryAnalysisScope(
	            "E:\\eclipse-workspace\\jlu", exFile);

	        // 构建ClassHierarchy，相当与类的一个层级结构

	         ClassHierarchy cha = ClassHierarchyFactory.make(scope);
	         
	         
	         Iterable<Entrypoint> entrypoints =Util.makeMainEntrypoints(scope, cha);
	         AnalysisOptions options = new AnalysisOptions(scope, entrypoints);
	         options.setReflectionOptions(ReflectionOptions.NONE);
	        
	         CallGraphBuilder<InstanceKey> builder = Util.makeVanillaZeroOneCFABuilder(null, options, new AnalysisCacheImpl(), cha, scope);

	         CallGraph cg = builder.makeCallGraph(options, null);
	         
	         final PointerAnalysis<InstanceKey> pa = builder.getPointerAnalysis(); 
	         SDG<?> sdg = new SDG<>(cg, pa, modRef, DataDependenceOptions.REFLECTION, ControlDependenceOptions.NO_EXCEPTIONAL_EDGES, null);
	         
	         
	         Collection<Statement> collection = null;
	         public CGNode findMethod(CallGraph cg1,String Name,String methodCLass) {
	        	 if(Name.equals(null) && methodCLass.equals(null))
	                 return null;
	        	 Atom name = Atom.findOrCreateUnicodeAtom(Name);
	        	 for (Iterator<? extends CGNode> it = cg1.iterator(); it.hasNext();) {
	                 CGNode n = it.next();
	                 if (n.getMethod().getName().equals(name) &&n.getMethod().getDeclaringClass().getName().toString().equals(methodCLass)) {
	                	 return n;
	                		  }
	                 Assertions.UNREACHABLE("Failed to find method " + name);
	                 return null;
	        	 }
	         }
	}
	        
}
